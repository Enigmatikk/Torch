//! View operations commands

use crate::cli::ViewOperation;
use colored::*;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

/// Handle view operations
pub fn handle_operation(operation: ViewOperation) -> Result<(), Box<dyn std::error::Error>> {
    match operation {
        ViewOperation::Cache => {
            cache_views()?;
        }
        ViewOperation::Clear => {
            clear_view_cache()?;
        }
    }
    Ok(())
}

/// Compile and cache all views
fn cache_views() -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Compiling and caching views...", "ðŸŽ¨".yellow());
    
    let templates_dir = "templates";
    if !Path::new(templates_dir).exists() {
        println!("{} No templates directory found", "â„¹ï¸".blue());
        return Ok(());
    }
    
    let cache_dir = "target/cache/views";
    fs::create_dir_all(cache_dir)?;
    
    let mut compiled_count = 0;
    
    // Walk through all .ember files
    for entry in WalkDir::new(templates_dir) {
        let entry = entry?;
        let path = entry.path();
        
        if path.extension().and_then(|s| s.to_str()) == Some("ember") {
            let relative_path = path.strip_prefix(templates_dir)?;
            let template_name = relative_path.to_string_lossy();
            
            println!("{} Compiling: {}", "ðŸ“".blue(), template_name.cyan());
            
            // Read template content
            let content = fs::read_to_string(path)?;
            
            // TODO: Implement actual Ember template compilation
            let compiled_content = compile_ember_template(&content, &template_name)?;
            
            // Write compiled template
            let cache_file = format!("{}/{}.rs", cache_dir, template_name.replace('/', "_").replace(".ember", ""));
            fs::write(&cache_file, compiled_content)?;
            
            compiled_count += 1;
        }
    }
    
    // Generate view cache index
    generate_view_cache_index(cache_dir)?;
    
    println!("{} Compiled {} templates successfully", "âœ…".green(), compiled_count);
    println!("{} Cache directory: {}", "ðŸ“".blue(), cache_dir.cyan());
    
    Ok(())
}

/// Clear all compiled view files
fn clear_view_cache() -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Clearing view cache...", "ðŸ—‘ï¸".yellow());
    
    let cache_dir = "target/cache/views";
    if Path::new(cache_dir).exists() {
        fs::remove_dir_all(cache_dir)?;
        println!("{} View cache cleared successfully", "âœ…".green());
    } else {
        println!("{} No view cache found", "â„¹ï¸".blue());
    }
    
    Ok(())
}

/// Compile an Ember template to Rust code
fn compile_ember_template(content: &str, template_name: &str) -> Result<String, Box<dyn std::error::Error>> {
    // TODO: Implement actual Ember template compilation
    // This is a simplified version for demonstration

    let function_name = template_name
        .replace('/', "_")
        .replace(".ember", "")
        .replace('-', "_");

    let escaped_content = content.replace('"', r#"\""#);

    let mut compiled = String::new();
    compiled.push_str(&format!("// Compiled template: {}\n", template_name));
    compiled.push_str("// This file is automatically generated. Do not edit manually.\n\n");
    compiled.push_str("use torch_web::{Response, ember::EmberEngine};\n");
    compiled.push_str("use serde_json::Value;\n\n");
    compiled.push_str(&format!("pub fn render_{}(data: &Value) -> Result<String, Box<dyn std::error::Error>> {{\n", function_name));
    compiled.push_str("    // TODO: Implement actual template rendering logic\n");
    compiled.push_str(&format!("    let template_content = r#\"{}\"#;\n", escaped_content));
    compiled.push_str("    \n");
    compiled.push_str("    // Simple variable replacement for demonstration\n");
    compiled.push_str("    let mut rendered = template_content.to_string();\n");
    compiled.push_str("    \n");
    compiled.push_str("    // Replace @yield directives\n");
    compiled.push_str("    rendered = rendered.replace(\"@yield('title', 'Default Title')\", \"{{ title }}\");\n");
    compiled.push_str("    rendered = rendered.replace(\"@yield('content')\", \"{{ content }}\");\n");
    compiled.push_str("    \n");
    compiled.push_str("    // Replace @section directives (simplified)\n");
    compiled.push_str("    rendered = rendered.replace(\"@section('title', \", \"\");\n");
    compiled.push_str("    rendered = rendered.replace(\"@section('content')\", \"\");\n");
    compiled.push_str("    rendered = rendered.replace(\"@endsection\", \"\");\n");
    compiled.push_str("    \n");
    compiled.push_str("    Ok(rendered)\n");
    compiled.push_str("}\n\n");
    compiled.push_str(&format!("pub fn render_{}_response(data: &Value) -> Response {{\n", function_name));
    compiled.push_str(&format!("    match render_{}(data) {{\n", function_name));
    compiled.push_str("        Ok(html) => Response::ok().html(html),\n");
    compiled.push_str("        Err(_) => Response::internal_server_error().body(\"Template rendering error\"),\n");
    compiled.push_str("    }\n");
    compiled.push_str("}\n");

    Ok(compiled)
}

/// Generate view cache index file
fn generate_view_cache_index(cache_dir: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut index_content = String::from(r#"// View cache index
// This file is automatically generated. Do not edit manually.

use serde_json::Value;
use torch_web::Response;
use std::collections::HashMap;

pub struct ViewCache {
    templates: HashMap<String, fn(&Value) -> Result<String, Box<dyn std::error::Error>>>,
}

impl ViewCache {
    pub fn new() -> Self {
        let mut templates = HashMap::new();
        
"#);
    
    // Scan for compiled templates and add them to the index
    for entry in WalkDir::new(cache_dir) {
        let entry = entry?;
        let path = entry.path();
        
        if path.extension().and_then(|s| s.to_str()) == Some("rs") {
            if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                index_content.push_str(&format!(
                    r#"        templates.insert("{}.ember".to_string(), super::{}::render_{});
"#,
                    file_stem.replace('_', "/"),
                    file_stem,
                    file_stem
                ));
            }
        }
    }
    
    index_content.push_str(r#"        
        Self { templates }
    }
    
    pub fn render(&self, template: &str, data: &Value) -> Result<String, Box<dyn std::error::Error>> {
        if let Some(renderer) = self.templates.get(template) {
            renderer(data)
        } else {
            Err(format!("Template '{}' not found in cache", template).into())
        }
    }
    
    pub fn render_response(&self, template: &str, data: &Value) -> Response {
        match self.render(template, data) {
            Ok(html) => Response::ok().html(html),
            Err(_) => Response::not_found().body("Template not found"),
        }
    }
}
"#);
    
    fs::write(format!("{}/mod.rs", cache_dir), index_content)?;
    
    Ok(())
}
