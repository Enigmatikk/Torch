//! Testing operations commands

use colored::*;
use std::process::Command;

/// Run tests with optional filters
pub fn run_tests(filter: Option<String>, unit: bool, integration: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Running Torch tests...", "🧪".yellow());
    
    let mut cmd = Command::new("cargo");
    cmd.arg("test");
    
    // Add test type filters
    if unit && !integration {
        cmd.arg("--lib");
        println!("{} Running unit tests only", "📝".blue());
    } else if integration && !unit {
        cmd.arg("--test");
        cmd.arg("*");
        println!("{} Running integration tests only", "🔗".blue());
    } else {
        println!("{} Running all tests", "🎯".blue());
    }
    
    // Add filter if provided
    if let Some(test_filter) = filter {
        cmd.arg(&test_filter);
        println!("{} Filter: {}", "🔍".blue(), test_filter.cyan());
    }
    
    // Add additional test arguments
    cmd.arg("--");
    cmd.arg("--nocapture");
    
    println!();
    
    let status = cmd.status()?;
    
    if status.success() {
        println!();
        println!("{} All tests passed!", "✅".green().bold());
    } else {
        println!();
        println!("{} Some tests failed", "❌".red().bold());
        return Err("Test failures detected".into());
    }
    
    Ok(())
}

/// Generate a new test file
pub fn generate_test(name: &str, unit: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating test: {}", "🧪".yellow(), name.cyan().bold());
    
    let test_name = if name.ends_with("Test") {
        name.to_string()
    } else {
        format!("{}Test", name)
    };
    
    let (filename, content) = if unit {
        let filename = format!("src/tests/{}.rs", test_name.to_lowercase());
        let content = generate_unit_test(&test_name);
        (filename, content)
    } else {
        let filename = format!("tests/{}.rs", test_name.to_lowercase());
        let content = generate_integration_test(&test_name);
        (filename, content)
    };
    
    // Create directory if it doesn't exist
    if let Some(parent) = std::path::Path::new(&filename).parent() {
        std::fs::create_dir_all(parent)?;
    }
    
    std::fs::write(&filename, content)?;
    
    println!("{} Test created: {}", "✅".green(), filename);
    
    if unit {
        println!("{} Unit test includes: basic test structure", "💡".blue());
    } else {
        println!("{} Integration test includes: full application testing", "💡".blue());
    }
    
    Ok(())
}

/// Generate unit test content
fn generate_unit_test(name: &str) -> String {
    format!(r#"//! {} - Generated by Torch CLI

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_example() {{
        // TODO: Add your unit tests here
        assert_eq!(2 + 2, 4);
    }}

    #[test]
    fn test_another_example() {{
        // TODO: Add more unit tests
        assert!(true);
    }}

    #[tokio::test]
    async fn test_async_example() {{
        // TODO: Add async unit tests here
        let result = async_function().await;
        assert!(result.is_ok());
    }}

    async fn async_function() -> Result<(), Box<dyn std::error::Error>> {{
        Ok(())
    }}
}}
"#, name)
}

/// Generate integration test content
fn generate_integration_test(name: &str) -> String {
    format!(r#"//! {} - Generated by Torch CLI

use torch_web::{{App, Request, Response}};
use tokio_test;

#[tokio::test]
async fn test_application_routes() {{
    let app = create_test_app().await;
    
    // TODO: Add your integration tests here
    // Test your application routes and functionality
    
    // Example: Test home route
    // let response = app.get("/").await;
    // assert_eq!(response.status(), 200);
}}

#[tokio::test]
async fn test_api_endpoints() {{
    let app = create_test_app().await;
    
    // TODO: Test your API endpoints
    // let response = app.post("/api/users")
    //     .json(&serde_json::json!({{"name": "Test User"}}))
    //     .await;
    // assert_eq!(response.status(), 201);
}}

#[tokio::test]
async fn test_middleware() {{
    let app = create_test_app().await;
    
    // TODO: Test your middleware
    // let response = app.get("/protected").await;
    // assert_eq!(response.status(), 401);
}}

async fn create_test_app() -> App {{
    // TODO: Set up your test application
    App::new()
        .get("/", |_req: Request| async {{
            Response::ok().body("Test response")
        }})
        .get("/api/users", |_req: Request| async {{
            Response::ok().json(&serde_json::json!({{"users": []}}))
        }})
}}

// Helper functions for testing
fn setup_test_database() {{
    // TODO: Set up test database
}}

fn cleanup_test_database() {{
    // TODO: Clean up test database
}}
"#, name)
}
