//! Code generation commands

use crate::cli::Generator;
use colored::*;
use std::fs;
use std::path::Path;

/// Generate code based on the generator type
pub fn generate(generator: Generator) -> Result<(), Box<dyn std::error::Error>> {
    match generator {
        Generator::Controller { name, resource, api } => {
            generate_controller(&name, resource, api)?;
        }
        Generator::Model { name, migration, factory, seeder, policy } => {
            generate_model(&name, migration, factory, seeder, policy)?;
        }
        Generator::Middleware { name } => {
            generate_middleware(&name)?;
        }
        Generator::Template { name, layout } => {
            generate_template(&name, layout.as_deref())?;
        }
        Generator::Migration { name, create, table } => {
            generate_migration(&name, create.as_deref(), table.as_deref())?;
        }
        Generator::Seeder { name } => {
            generate_seeder(&name)?;
        }
        Generator::Factory { name, model } => {
            generate_factory(&name, model.as_deref())?;
        }
        Generator::Policy { name, model } => {
            generate_policy(&name, model.as_deref())?;
        }
        Generator::Event { name } => {
            generate_event(&name)?;
        }
        Generator::Listener { name, event } => {
            generate_listener(&name, event.as_deref())?;
        }
        Generator::Job { name, sync } => {
            generate_job(&name, sync)?;
        }
        Generator::Notification { name } => {
            generate_notification(&name)?;
        }
        Generator::Test { name, unit } => {
            super::test::generate_test(&name, unit)?;
        }
        Generator::Command { name } => {
            generate_command(&name)?;
        }
    }
    Ok(())
}

fn generate_controller(name: &str, resource: bool, api: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating controller: {}", "üéÆ".yellow(), name.cyan().bold());
    
    let controller_name = if name.ends_with("Controller") {
        name.to_string()
    } else {
        format!("{}Controller", name)
    };
    
    let filename = format!("src/controllers/{}.rs", controller_name.to_lowercase());
    
    // Create controllers directory if it doesn't exist
    fs::create_dir_all("src/controllers")?;
    
    let content = if resource {
        if api {
            generate_api_resource_controller(&controller_name)
        } else {
            generate_resource_controller(&controller_name)
        }
    } else {
        generate_basic_controller(&controller_name)
    };
    
    fs::write(&filename, content)?;
    
    println!("{} Controller created: {}", "‚úÖ".green(), filename);
    
    if resource {
        if api {
            println!("{} API resource controller includes: index, show, store, update, destroy", "üí°".blue());
        } else {
            println!("{} Resource controller includes: index, show, create, update, delete", "üí°".blue());
        }
    }
    
    Ok(())
}

fn generate_basic_controller(name: &str) -> String {
    format!(r#"//! {} - Generated by Torch CLI

use torch_web::{{Request, Response, extractors::*}};

pub struct {} {{}}

impl {} {{
    /// Handle requests
    pub async fn handle(req: Request) -> Response {{
        Response::ok().body("Hello from {}!")
    }}
}}
"#, name, name, name, name)
}

fn generate_resource_controller(name: &str) -> String {
    let model_name = name.replace("Controller", "");
    
    format!(r#"//! {} - Generated by Torch CLI

use torch_web::{{Request, Response, extractors::*}};
use serde::{{Deserialize, Serialize}};

pub struct {} {{}}

#[derive(Deserialize)]
pub struct Create{}Request {{
    // Add your fields here
}}

#[derive(Deserialize)]
pub struct Update{}Request {{
    // Add your fields here
}}

impl {} {{
    /// GET / - List all {}s
    pub async fn index(Query(params): Query<std::collections::HashMap<String, String>>) -> Response {{
        // TODO: Fetch {}s from database
        Response::ok().json(&serde_json::json!({{
            "{}s": [],
            "message": "List all {}s"
        }}))
    }}
    
    /// GET /:id - Show specific {}
    pub async fn show(Path(id): Path<u32>) -> Response {{
        // TODO: Fetch {} from database
        Response::ok().json(&serde_json::json!({{
            "id": id,
            "message": "Show {} {{}}"
        }}))
    }}
    
    /// POST / - Create new {}
    pub async fn create(Json(req): Json<Create{}Request>) -> Response {{
        // TODO: Create {} in database
        Response::created().json(&serde_json::json!({{
            "message": "{} created successfully"
        }}))
    }}
    
    /// PUT /:id - Update {}
    pub async fn update(Path(id): Path<u32>, Json(req): Json<Update{}Request>) -> Response {{
        // TODO: Update {} in database
        Response::ok().json(&serde_json::json!({{
            "id": id,
            "message": "{} updated successfully"
        }}))
    }}
    
    /// DELETE /:id - Delete {}
    pub async fn delete(Path(id): Path<u32>) -> Response {{
        // TODO: Delete {} from database
        Response::ok().json(&serde_json::json!({{
            "id": id,
            "message": "{} deleted successfully"
        }}))
    }}
}}
"#, 
        name, name, model_name, model_name, name,
        model_name.to_lowercase(), model_name.to_lowercase(),
        model_name.to_lowercase(), model_name.to_lowercase(),
        model_name, model_name, model_name,
        model_name, name, model_name, model_name,
        model_name, name, model_name, model_name,
        model_name, model_name, model_name
    )
}

fn generate_model(name: &str, migration: bool, factory: bool, seeder: bool, policy: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating model: {}", "üìä".yellow(), name.cyan().bold());

    let model_name = if name.ends_with("Model") {
        name.to_string()
    } else {
        name.to_string()
    };

    let filename = format!("src/models/{}.rs", model_name.to_lowercase());

    // Create models directory if it doesn't exist
    fs::create_dir_all("src/models")?;

    let content = generate_model_content(&model_name);
    fs::write(&filename, content)?;

    println!("{} Model created: {}", "‚úÖ".green(), filename);

    // Generate additional files if requested
    if migration {
        generate_migration(&format!("create_{}_table", model_name.to_lowercase()), None, None)?;
    }

    if factory {
        generate_factory(&format!("{}Factory", model_name), Some(&model_name))?;
    }

    if seeder {
        generate_seeder(&format!("{}Seeder", model_name))?;
    }

    if policy {
        generate_policy(&format!("{}Policy", model_name), Some(&model_name))?;
    }

    Ok(())
}

fn generate_middleware(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating middleware: {}", "üõ°Ô∏è".yellow(), name.cyan().bold());
    
    let middleware_name = if name.ends_with("Middleware") {
        name.to_string()
    } else {
        format!("{}Middleware", name)
    };
    
    let filename = format!("src/middleware/{}.rs", middleware_name.to_lowercase());
    
    // Create middleware directory if it doesn't exist
    fs::create_dir_all("src/middleware")?;
    
    let content = format!(r#"//! {} - Generated by Torch CLI

use torch_web::{{Request, Response, middleware::Middleware}};
use std::pin::Pin;
use std::future::Future;

pub struct {} {{}}

impl {} {{
    pub fn new() -> Self {{
        Self {{}}
    }}
}}

impl Middleware for {} {{
    fn call(
        &self,
        req: Request,
        next: Box<dyn Fn(Request) -> Pin<Box<dyn Future<Output = Response> + Send + 'static>> + Send + Sync>,
    ) -> Pin<Box<dyn Future<Output = Response> + Send + 'static>> {{
        Box::pin(async move {{
            // TODO: Add your middleware logic here

            // Process request before handler
            println!("Processing request in {}", "{}");

            // Call next middleware/handler
            let response = next(req).await;

            // Process response after handler
            println!("Processing response in {}", "{}");

            response
        }})
    }}
}}
"#, middleware_name, middleware_name, middleware_name, middleware_name, middleware_name, middleware_name, middleware_name, middleware_name);
    
    fs::write(&filename, content)?;
    
    println!("{} Middleware created: {}", "‚úÖ".green(), filename);
    
    Ok(())
}

/// Generate API resource controller content
fn generate_api_resource_controller(name: &str) -> String {
    let model_name = name.replace("Controller", "");

    format!(r#"//! {} - Generated by Torch CLI

use torch_web::{{Request, Response, extractors::*}};
use serde::{{Deserialize, Serialize}};

pub struct {} {{}}

#[derive(Deserialize)]
pub struct Create{}Request {{
    // Add your fields here
}}

#[derive(Deserialize)]
pub struct Update{}Request {{
    // Add your fields here
}}

#[derive(Serialize)]
pub struct {}Response {{
    pub id: u32,
    // Add your response fields here
}}

impl {} {{
    /// GET /api/{} - List all {}s
    pub async fn index(Query(params): Query<std::collections::HashMap<String, String>>) -> Response {{
        // TODO: Fetch {}s from database
        Response::ok().json(&serde_json::json!({{
            "data": [],
            "meta": {{
                "total": 0,
                "page": 1,
                "per_page": 15
            }}
        }}))
    }}

    /// GET /api/{}/:id - Show specific {}
    pub async fn show(Path(id): Path<u32>) -> Response {{
        // TODO: Fetch {} from database
        Response::ok().json(&serde_json::json!({{
            "data": {{
                "id": id,
                "message": "Show {} {{}}"
            }}
        }}))
    }}

    /// POST /api/{} - Create new {}
    pub async fn store(Json(req): Json<Create{}Request>) -> Response {{
        // TODO: Create {} in database
        Response::created().json(&serde_json::json!({{
            "data": {{
                "id": 1,
                "message": "{} created successfully"
            }}
        }}))
    }}

    /// PUT /api/{}/:id - Update {}
    pub async fn update(Path(id): Path<u32>, Json(req): Json<Update{}Request>) -> Response {{
        // TODO: Update {} in database
        Response::ok().json(&serde_json::json!({{
            "data": {{
                "id": id,
                "message": "{} updated successfully"
            }}
        }}))
    }}

    /// DELETE /api/{}/:id - Delete {}
    pub async fn destroy(Path(id): Path<u32>) -> Response {{
        // TODO: Delete {} from database
        Response::ok().json(&serde_json::json!({{
            "data": {{
                "id": id,
                "message": "{} deleted successfully"
            }}
        }}))
    }}
}}
"#,
        name, name, model_name, model_name, model_name, name,
        model_name.to_lowercase(), model_name.to_lowercase(), model_name.to_lowercase(),
        model_name.to_lowercase(), model_name, model_name, model_name,
        model_name.to_lowercase(), model_name, name, model_name, model_name,
        model_name.to_lowercase(), model_name, name, model_name, model_name,
        model_name.to_lowercase(), model_name, model_name, model_name
    )
}

/// Generate model content with ORM support
fn generate_model_content(name: &str) -> String {
    let table_name = format!("{}s", name.to_lowercase());

    format!(r#"//! {name} - Generated by Torch CLI
//!
//! This model uses Torch's Laravel Eloquent-style ORM for database operations.

use serde::{{Deserialize, Serialize}};

#[cfg(feature = "database")]
use torch_web::orm::{{Model, Timestamps, HasRelationships, impl_model, impl_timestamps, impl_from_row}};

/// {name} model with Active Record functionality
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "database", derive(sqlx::FromRow))]
pub struct {name} {{
    /// Primary key
    pub id: Option<i32>,

    // TODO: Add your model fields here
    // Example fields:
    // pub name: String,
    // pub email: String,
    // pub active: bool,

    /// Timestamp fields (automatically managed)
    #[cfg(feature = "database")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[cfg(feature = "database")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}}

// Implement ORM traits when database feature is enabled
#[cfg(feature = "database")]
impl_model!({name}, table = "{table_name}", primary_key = "id", primary_key_type = i32);

#[cfg(feature = "database")]
impl_timestamps!({name});

#[cfg(feature = "database")]
impl_from_row!({name}, {{ id, created_at, updated_at }});

impl {name} {{
    /// Create a new instance
    pub fn new() -> Self {{
        Self {{
            id: None,
            // TODO: Initialize your fields
            #[cfg(feature = "database")]
            created_at: None,
            #[cfg(feature = "database")]
            updated_at: None,
        }}
    }}

    /// Custom validation logic
    #[cfg(feature = "database")]
    pub fn validate(&self) -> torch_web::orm::Result<()> {{
        // TODO: Add your validation rules here
        Ok(())
    }}

    // TODO: Add relationship methods here
    // TODO: Add custom query methods here
}}

// Implement Default trait
impl Default for {name} {{
    fn default() -> Self {{
        Self::new()
    }}
}}"#,
        name = name,
        table_name = table_name
    )
}

/// Generate migration
fn generate_migration(name: &str, create: Option<&str>, table: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating migration: {}", "üìù".yellow(), name.cyan().bold());

    let timestamp = chrono::Utc::now().format("%Y_%m_%d_%H%M%S");
    let filename = format!("migrations/{}_{}.rs", timestamp, name);

    // Create migrations directory if it doesn't exist
    fs::create_dir_all("migrations")?;

    let content = if let Some(table_name) = create {
        crate::cli::generators::generate_create_table_migration(name, table_name)
    } else if let Some(table_name) = table {
        crate::cli::generators::generate_modify_table_migration(name, table_name)
    } else {
        crate::cli::generators::generate_basic_migration(name)
    };

    fs::write(&filename, content)?;

    println!("{} Migration created: {}", "‚úÖ".green(), filename);

    Ok(())
}

/// Generate seeder
fn generate_seeder(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating seeder: {}", "üå±".yellow(), name.cyan().bold());

    let seeder_name = if name.ends_with("Seeder") {
        name.to_string()
    } else {
        format!("{}Seeder", name)
    };

    let filename = format!("src/seeders/{}.rs", seeder_name.to_lowercase());

    // Create seeders directory if it doesn't exist
    fs::create_dir_all("src/seeders")?;

    let content = crate::cli::generators::generate_seeder_content(&seeder_name);
    fs::write(&filename, content)?;

    println!("{} Seeder created: {}", "‚úÖ".green(), filename);

    Ok(())
}

/// Generate factory
fn generate_factory(name: &str, model: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating factory: {}", "üè≠".yellow(), name.cyan().bold());

    let factory_name = if name.ends_with("Factory") {
        name.to_string()
    } else {
        format!("{}Factory", name)
    };

    let default_model = name.replace("Factory", "");
    let model_name = model.unwrap_or(&default_model);

    let filename = format!("src/factories/{}.rs", factory_name.to_lowercase());

    // Create factories directory if it doesn't exist
    fs::create_dir_all("src/factories")?;

    let content = crate::cli::generators::generate_factory_content(&factory_name, &model_name);
    fs::write(&filename, content)?;

    println!("{} Factory created: {}", "‚úÖ".green(), filename);

    Ok(())
}

/// Generate policy
fn generate_policy(name: &str, model: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating policy: {}", "üõ°Ô∏è".yellow(), name.cyan().bold());

    let policy_name = if name.ends_with("Policy") {
        name.to_string()
    } else {
        format!("{}Policy", name)
    };

    let default_model = name.replace("Policy", "");
    let model_name = model.unwrap_or(&default_model);

    let filename = format!("src/policies/{}.rs", policy_name.to_lowercase());

    // Create policies directory if it doesn't exist
    fs::create_dir_all("src/policies")?;

    let content = crate::cli::generators::generate_policy_content(&policy_name, &model_name);
    fs::write(&filename, content)?;

    println!("{} Policy created: {}", "‚úÖ".green(), filename);

    Ok(())
}

/// Generate event
fn generate_event(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating event: {}", "üì°".yellow(), name.cyan().bold());

    let event_name = if name.ends_with("Event") {
        name.to_string()
    } else {
        name.to_string()
    };

    let filename = format!("src/events/{}.rs", event_name.to_lowercase());

    // Create events directory if it doesn't exist
    fs::create_dir_all("src/events")?;

    let content = crate::cli::generators::generate_event_content(&event_name);
    fs::write(&filename, content)?;

    println!("{} Event created: {}", "‚úÖ".green(), filename);

    Ok(())
}

/// Generate listener
fn generate_listener(name: &str, event: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating listener: {}", "üëÇ".yellow(), name.cyan().bold());

    let listener_name = if name.ends_with("Listener") {
        name.to_string()
    } else {
        name.to_string()
    };

    let event_name = event.unwrap_or("SomeEvent");

    let filename = format!("src/listeners/{}.rs", listener_name.to_lowercase());

    // Create listeners directory if it doesn't exist
    fs::create_dir_all("src/listeners")?;

    let content = crate::cli::generators::generate_listener_content(&listener_name, event_name);
    fs::write(&filename, content)?;

    println!("{} Listener created: {}", "‚úÖ".green(), filename);

    if let Some(event_name) = event {
        println!("{} Listening for event: {}", "üëÇ".blue(), event_name.cyan());
    }

    Ok(())
}

/// Generate job
fn generate_job(name: &str, sync: bool) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating job: {}", "‚ö°".yellow(), name.cyan().bold());

    let job_name = if name.ends_with("Job") {
        name.to_string()
    } else {
        format!("{}Job", name)
    };

    let filename = format!("src/jobs/{}.rs", job_name.to_lowercase());

    // Create jobs directory if it doesn't exist
    fs::create_dir_all("src/jobs")?;

    let content = crate::cli::generators::generate_job_content(&job_name, sync);
    fs::write(&filename, content)?;

    println!("{} Job created: {}", "‚úÖ".green(), filename);

    if sync {
        println!("{} Synchronous job (will run immediately)", "‚ö°".blue());
    } else {
        println!("{} Asynchronous job (will be queued)", "üìã".blue());
    }

    Ok(())
}

/// Generate notification
fn generate_notification(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating notification: {}", "üì¨".yellow(), name.cyan().bold());

    let notification_name = if name.ends_with("Notification") {
        name.to_string()
    } else {
        format!("{}Notification", name)
    };

    let filename = format!("src/notifications/{}.rs", notification_name.to_lowercase());

    // Create notifications directory if it doesn't exist
    fs::create_dir_all("src/notifications")?;

    let content = crate::cli::generators::generate_notification_content(&notification_name);
    fs::write(&filename, content)?;

    println!("{} Notification created: {}", "‚úÖ".green(), filename);

    Ok(())
}

/// Generate command
fn generate_command(name: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating command: {}", "‚öôÔ∏è".yellow(), name.cyan().bold());

    let command_name = if name.ends_with("Command") {
        name.to_string()
    } else {
        format!("{}Command", name)
    };

    let filename = format!("src/commands/{}.rs", command_name.to_lowercase());

    // Create commands directory if it doesn't exist
    fs::create_dir_all("src/commands")?;

    let content = crate::cli::generators::generate_command_content(&command_name);
    fs::write(&filename, content)?;

    println!("{} Command created: {}", "‚úÖ".green(), filename);
    println!("{} Don't forget to register the command in your CLI", "üí°".blue());

    Ok(())
}

fn generate_template(name: &str, layout: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} Generating template: {}", "üé®".yellow(), name.cyan().bold());
    
    let filename = format!("templates/{}.ember", name);
    
    // Create templates directory if it doesn't exist
    if let Some(parent) = Path::new(&filename).parent() {
        fs::create_dir_all(parent)?;
    }
    
    let layout_name = layout.unwrap_or("layout");
    
    let content = format!(r#"@extends('{}')

@section('title', '{}')

@section('content')
    <div class="container">
        <h1>{}</h1>
        <p>This template was generated by Torch CLI.</p>
        
        {{{{-- Add your content here --}}}}
    </div>
@endsection
"#, layout_name, name.replace('/', " - "), name.replace('/', " "));

    fs::write(&filename, content)?;

    println!("{} Template created: {}", "‚úÖ".green(), filename);

    Ok(())
}
