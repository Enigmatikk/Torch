//! Code generators for Torch CLI

/// Generate create table migration content
pub fn generate_create_table_migration(name: &str, table_name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use sqlx::{Pool, Postgres};\n\n");
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub async fn up(pool: &Pool<Postgres>) -> Result<(), sqlx::Error> {\n");
    content.push_str(&format!("        sqlx::query!(r#\"\n"));
    content.push_str(&format!("            CREATE TABLE {} (\n", table_name));
    content.push_str("                id SERIAL PRIMARY KEY,\n");
    content.push_str("                -- TODO: Add your columns here\n");
    content.push_str("                -- name VARCHAR NOT NULL,\n");
    content.push_str("                -- email VARCHAR UNIQUE NOT NULL,\n");
    content.push_str("                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n");
    content.push_str("                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n");
    content.push_str("            )\n");
    content.push_str("        \"#)\n");
    content.push_str("        .execute(pool)\n");
    content.push_str("        .await?;\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n\n");
    content.push_str("    pub async fn down(pool: &Pool<Postgres>) -> Result<(), sqlx::Error> {\n");
    content.push_str(&format!("        sqlx::query!(r#\"DROP TABLE IF EXISTS {}\"#)\n", table_name));
    content.push_str("            .execute(pool)\n");
    content.push_str("            .await?;\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("}\n");
    
    content
}

/// Generate modify table migration content
pub fn generate_modify_table_migration(name: &str, table_name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use sqlx::{Pool, Postgres};\n\n");
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub async fn up(pool: &Pool<Postgres>) -> Result<(), sqlx::Error> {\n");
    content.push_str("        // TODO: Add your table modifications here\n");
    content.push_str("        // Examples:\n");
    content.push_str(&format!("        // sqlx::query!(r#\"ALTER TABLE {} ADD COLUMN new_column VARCHAR\"#)\n", table_name));
    content.push_str("        //     .execute(pool)\n");
    content.push_str("        //     .await?;\n");
    content.push_str("        \n");
    content.push_str(&format!("        // sqlx::query!(r#\"ALTER TABLE {} DROP COLUMN old_column\"#)\n", table_name));
    content.push_str("        //     .execute(pool)\n");
    content.push_str("        //     .await?;\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    pub async fn down(pool: &Pool<Postgres>) -> Result<(), sqlx::Error> {\n");
    content.push_str("        // TODO: Add rollback logic here\n");
    content.push_str("        // Examples:\n");
    content.push_str(&format!("        // sqlx::query!(r#\"ALTER TABLE {} DROP COLUMN new_column\"#)\n", table_name));
    content.push_str("        //     .execute(pool)\n");
    content.push_str("        //     .await?;\n");
    content.push_str("        \n");
    content.push_str(&format!("        // sqlx::query!(r#\"ALTER TABLE {} ADD COLUMN old_column VARCHAR\"#)\n", table_name));
    content.push_str("        //     .execute(pool)\n");
    content.push_str("        //     .await?;\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("}\n");
    
    content
}

/// Generate basic migration content
pub fn generate_basic_migration(name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use sqlx::{Pool, Postgres};\n\n");
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub async fn up(pool: &Pool<Postgres>) -> Result<(), sqlx::Error> {\n");
    content.push_str("        // TODO: Add your migration logic here\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    pub async fn down(pool: &Pool<Postgres>) -> Result<(), sqlx::Error> {\n");
    content.push_str("        // TODO: Add rollback logic here\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("}\n");
    
    content
}

/// Generate seeder content
pub fn generate_seeder_content(name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use sqlx::{Pool, Postgres};\n\n");
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub async fn run(pool: &Pool<Postgres>) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    content.push_str(&format!("        println!(\"Seeding {}...\", \"{}\");\n", name.replace("Seeder", ""), name.replace("Seeder", "")));
    content.push_str("        \n");
    content.push_str("        // TODO: Add your seeding logic here\n");
    content.push_str("        // Example:\n");
    content.push_str("        // sqlx::query!(r#\"\n");
    content.push_str("        //     INSERT INTO users (name, email) VALUES \n");
    content.push_str("        //     ('John Doe', 'john@example.com'),\n");
    content.push_str("        //     ('Jane Smith', 'jane@example.com')\n");
    content.push_str("        // \"#)\n");
    content.push_str("        // .execute(pool)\n");
    content.push_str("        // .await?;\n");
    content.push_str("        \n");
    content.push_str(&format!("        println!(\"Seeded {} successfully\", \"{}\");\n", name.replace("Seeder", ""), name.replace("Seeder", "")));
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("}\n");
    
    content
}

/// Generate factory content
pub fn generate_factory_content(name: &str, model_name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str(&format!("use crate::models::{};\n", model_name));
    content.push_str("use fake::{Fake, Faker};\n\n");
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str(&format!("    /// Create a new {} instance with fake data\n", model_name));
    content.push_str(&format!("    pub fn make() -> {} {{\n", model_name));
    content.push_str(&format!("        {} {{\n", model_name));
    content.push_str("            id: None,\n");
    content.push_str("            // TODO: Add fake data generation\n");
    content.push_str("            // name: Faker.fake(),\n");
    content.push_str("            // email: Faker.fake(),\n");
    content.push_str("            // created_at: Some(chrono::Utc::now()),\n");
    content.push_str("            // updated_at: Some(chrono::Utc::now()),\n");
    content.push_str("        }\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Create multiple {} instances\n", model_name));
    content.push_str(&format!("    pub fn make_many(count: usize) -> Vec<{}> {{\n", model_name));
    content.push_str("        (0..count).map(|_| Self::make()).collect()\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Create and save a {} instance to the database\n", model_name));
    content.push_str(&format!("    pub async fn create() -> Result<{}, Box<dyn std::error::Error + Send + Sync>> {{\n", model_name));
    content.push_str("        let mut instance = Self::make();\n");
    content.push_str("        instance.save().await?;\n");
    content.push_str("        Ok(instance)\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Create and save multiple {} instances to the database\n", model_name));
    content.push_str(&format!("    pub async fn create_many(count: usize) -> Result<Vec<{}>, Box<dyn std::error::Error + Send + Sync>> {{\n", model_name));
    content.push_str("        let mut instances = Vec::new();\n");
    content.push_str("        \n");
    content.push_str("        for _ in 0..count {\n");
    content.push_str("            let mut instance = Self::make();\n");
    content.push_str("            instance.save().await?;\n");
    content.push_str("            instances.push(instance);\n");
    content.push_str("        }\n");
    content.push_str("        \n");
    content.push_str("        Ok(instances)\n");
    content.push_str("    }\n");
    content.push_str("}\n");
    
    content
}

/// Generate policy content
pub fn generate_policy_content(name: &str, model_name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str(&format!("use crate::models::{};\n\n", model_name));
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str(&format!("    /// Determine if the user can view any {}s\n", model_name));
    content.push_str("    pub fn view_any(&self, user: &User) -> bool {\n");
    content.push_str("        // TODO: Implement authorization logic\n");
    content.push_str("        true\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Determine if the user can view the {}\n", model_name));
    content.push_str(&format!("    pub fn view(&self, user: &User, {}: &{}) -> bool {{\n", model_name.to_lowercase(), model_name));
    content.push_str("        // TODO: Implement authorization logic\n");
    content.push_str("        true\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Determine if the user can create {}s\n", model_name));
    content.push_str("    pub fn create(&self, user: &User) -> bool {\n");
    content.push_str("        // TODO: Implement authorization logic\n");
    content.push_str("        true\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Determine if the user can update the {}\n", model_name));
    content.push_str(&format!("    pub fn update(&self, user: &User, {}: &{}) -> bool {{\n", model_name.to_lowercase(), model_name));
    content.push_str("        // TODO: Implement authorization logic\n");
    content.push_str(&format!("        // Example: user.id == {}.user_id\n", model_name.to_lowercase()));
    content.push_str("        true\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str(&format!("    /// Determine if the user can delete the {}\n", model_name));
    content.push_str(&format!("    pub fn delete(&self, user: &User, {}: &{}) -> bool {{\n", model_name.to_lowercase(), model_name));
    content.push_str("        // TODO: Implement authorization logic\n");
    content.push_str(&format!("        // Example: user.id == {}.user_id\n", model_name.to_lowercase()));
    content.push_str("        true\n");
    content.push_str("    }\n");
    content.push_str("}\n\n");
    content.push_str("// TODO: Define your User model or import it\n");
    content.push_str("#[derive(Debug)]\n");
    content.push_str("pub struct User {\n");
    content.push_str("    pub id: u32,\n");
    content.push_str("    // Add other user fields\n");
    content.push_str("}\n");
    
    content
}

/// Generate event content
pub fn generate_event_content(name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use serde::{Deserialize, Serialize};\n");
    content.push_str("use chrono::{DateTime, Utc};\n\n");
    content.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    content.push_str(&format!("pub struct {} {{\n", name));
    content.push_str("    pub id: String,\n");
    content.push_str("    pub timestamp: DateTime<Utc>,\n");
    content.push_str("    // TODO: Add your event data fields\n");
    content.push_str("    // pub user_id: u32,\n");
    content.push_str("    // pub data: serde_json::Value,\n");
    content.push_str("}\n\n");
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub fn new() -> Self {\n");
    content.push_str("        Self {\n");
    content.push_str("            id: uuid::Uuid::new_v4().to_string(),\n");
    content.push_str("            timestamp: Utc::now(),\n");
    content.push_str("            // TODO: Initialize your fields\n");
    content.push_str("        }\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Dispatch the event to all listeners\n");
    content.push_str("    pub async fn dispatch(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    content.push_str("        // TODO: Implement event dispatching\n");
    content.push_str("        println!(\"Dispatching event: {}\", self.id);\n");
    content.push_str("        \n");
    content.push_str("        // Example: Send to event bus or queue\n");
    content.push_str("        // event_bus.publish(self).await?;\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Get event name for routing\n");
    content.push_str("    pub fn event_name(&self) -> &'static str {\n");
    content.push_str(&format!("        \"{}\"\n", name));
    content.push_str("    }\n");
    content.push_str("}\n\n");
    content.push_str(&format!("impl Default for {} {{\n", name));
    content.push_str("    fn default() -> Self {\n");
    content.push_str("        Self::new()\n");
    content.push_str("    }\n");
    content.push_str("}\n");

    content
}

/// Generate listener content
pub fn generate_listener_content(name: &str, event_name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str(&format!("use crate::events::{};\n\n", event_name));
    content.push_str(&format!("pub struct {} {{}}\n\n", name));
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    /// Handle the event\n");
    content.push_str(&format!("    pub async fn handle(&self, event: &{}) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {{\n", event_name));
    content.push_str("        println!(\"Handling event: {} at {}\", event.event_name(), event.timestamp);\n");
    content.push_str("        \n");
    content.push_str("        // TODO: Implement your event handling logic\n");
    content.push_str("        // Examples:\n");
    content.push_str("        // - Send email notifications\n");
    content.push_str("        // - Update database records\n");
    content.push_str("        // - Log events\n");
    content.push_str("        // - Trigger other processes\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Determine if the listener should handle this event\n");
    content.push_str(&format!("    pub fn should_handle(&self, event: &{}) -> bool {{\n", event_name));
    content.push_str("        // TODO: Add conditional logic if needed\n");
    content.push_str("        // Example: event.user_id.is_some()\n");
    content.push_str("        true\n");
    content.push_str("    }\n");
    content.push_str("}\n");

    content
}

/// Generate job content
pub fn generate_job_content(name: &str, sync: bool) -> String {
    let job_type = if sync { "Synchronous" } else { "Asynchronous" };

    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use serde::{Deserialize, Serialize};\n");
    content.push_str("use chrono::{DateTime, Utc};\n\n");
    content.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    content.push_str(&format!("pub struct {} {{\n", name));
    content.push_str("    pub id: String,\n");
    content.push_str("    pub created_at: DateTime<Utc>,\n");
    content.push_str("    // TODO: Add your job data fields\n");
    content.push_str("    // pub user_id: u32,\n");
    content.push_str("    // pub data: serde_json::Value,\n");
    content.push_str("}\n\n");
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub fn new() -> Self {\n");
    content.push_str("        Self {\n");
    content.push_str("            id: uuid::Uuid::new_v4().to_string(),\n");
    content.push_str("            created_at: Utc::now(),\n");
    content.push_str("            // TODO: Initialize your fields\n");
    content.push_str("        }\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Execute the job\n");
    content.push_str("    pub async fn handle(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    content.push_str(&format!("        println!(\"Executing {} job: {{}}\", self.id);\n", job_type));
    content.push_str("        \n");
    content.push_str("        // TODO: Implement your job logic\n");
    content.push_str("        // Examples:\n");
    content.push_str("        // - Process payments\n");
    content.push_str("        // - Send emails\n");
    content.push_str("        // - Generate reports\n");
    content.push_str("        // - Sync data with external APIs\n");
    content.push_str("        \n");
    content.push_str("        // Simulate work\n");
    content.push_str("        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n");
    content.push_str("        \n");
    content.push_str("        println!(\"Job {} completed successfully\", self.id);\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Get job name for queue routing\n");
    content.push_str("    pub fn job_name(&self) -> &'static str {\n");
    content.push_str(&format!("        \"{}\"\n", name));
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Determine if this job should run synchronously\n");
    content.push_str("    pub fn is_sync(&self) -> bool {\n");
    content.push_str(&format!("        {}\n", sync));
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Get job priority (higher number = higher priority)\n");
    content.push_str("    pub fn priority(&self) -> u8 {\n");
    content.push_str("        // TODO: Set job priority (0-255)\n");
    content.push_str("        100\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Get maximum retry attempts\n");
    content.push_str("    pub fn max_retries(&self) -> u8 {\n");
    content.push_str("        // TODO: Set maximum retry attempts\n");
    content.push_str("        3\n");
    content.push_str("    }\n");
    content.push_str("}\n");

    content
}

/// Generate notification content
pub fn generate_notification_content(name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use serde::{Deserialize, Serialize};\n");
    content.push_str("use chrono::{DateTime, Utc};\n\n");
    content.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    content.push_str(&format!("pub struct {} {{\n", name));
    content.push_str("    pub id: String,\n");
    content.push_str("    pub created_at: DateTime<Utc>,\n");
    content.push_str("    // TODO: Add your notification data fields\n");
    content.push_str("    // pub recipient_id: u32,\n");
    content.push_str("    // pub title: String,\n");
    content.push_str("    // pub message: String,\n");
    content.push_str("    // pub data: serde_json::Value,\n");
    content.push_str("}\n\n");
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    pub fn new() -> Self {\n");
    content.push_str("        Self {\n");
    content.push_str("            id: uuid::Uuid::new_v4().to_string(),\n");
    content.push_str("            created_at: Utc::now(),\n");
    content.push_str("            // TODO: Initialize your fields\n");
    content.push_str("        }\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Send the notification via email\n");
    content.push_str("    pub async fn via_email(&self, recipient: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    content.push_str("        println!(\"Sending email notification to: {}\", recipient);\n");
    content.push_str("        \n");
    content.push_str("        // TODO: Implement email sending logic\n");
    content.push_str("        // Example with a mail service:\n");
    content.push_str("        // let email = Email::new()\n");
    content.push_str("        //     .to(recipient)\n");
    content.push_str("        //     .subject(&self.title)\n");
    content.push_str("        //     .body(&self.message);\n");
    content.push_str("        // mail_service.send(email).await?;\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("    \n");
    content.push_str("    /// Get notification channels\n");
    content.push_str("    pub fn channels(&self) -> Vec<&'static str> {\n");
    content.push_str("        // TODO: Define which channels this notification should use\n");
    content.push_str("        vec![\"email\", \"database\"]\n");
    content.push_str("    }\n");
    content.push_str("}\n");

    content
}

/// Generate command content
pub fn generate_command_content(name: &str) -> String {
    let mut content = String::new();
    content.push_str(&format!("//! {} - Generated by Torch CLI\n\n", name));
    content.push_str("use clap::{Args, Parser};\n");
    content.push_str("use colored::*;\n\n");
    content.push_str("#[derive(Debug, Parser)]\n");
    content.push_str(&format!("#[command(name = \"{}\")]\n", name.to_lowercase()));
    content.push_str("#[command(about = \"TODO: Add command description\")]\n");
    content.push_str(&format!("pub struct {} {{\n", name));
    content.push_str("    /// TODO: Add command arguments\n");
    content.push_str("    #[arg(short, long)]\n");
    content.push_str("    pub verbose: bool,\n");
    content.push_str("    \n");
    content.push_str("    // Example arguments:\n");
    content.push_str("    // #[arg(short, long)]\n");
    content.push_str("    // pub input: Option<String>,\n");
    content.push_str("    \n");
    content.push_str("    // #[arg(short, long, default_value = \"output.txt\")]\n");
    content.push_str("    // pub output: String,\n");
    content.push_str("}\n\n");
    content.push_str(&format!("impl {} {{\n", name));
    content.push_str("    /// Execute the command\n");
    content.push_str("    pub async fn run(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    content.push_str("        if self.verbose {\n");
    content.push_str(&format!("            println!(\"{{}} Running {} command...\", \"🔧\".yellow());\n", name));
    content.push_str("        }\n");
    content.push_str("        \n");
    content.push_str("        // TODO: Implement your command logic\n");
    content.push_str("        // Examples:\n");
    content.push_str("        // - Process files\n");
    content.push_str("        // - Interact with databases\n");
    content.push_str("        // - Call external APIs\n");
    content.push_str("        // - Generate reports\n");
    content.push_str("        \n");
    content.push_str("        println!(\"{} Command executed successfully!\", \"✅\".green());\n");
    content.push_str("        \n");
    content.push_str("        Ok(())\n");
    content.push_str("    }\n");
    content.push_str("}\n");

    content
}
